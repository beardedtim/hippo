const http = require('http')
const utils = require('@/utils')
const url = require('url');
const { ReadStream } = require('fs');
/**
 * Our Next Function
 *
 * @typedef {function(): (Promise<void> | void)} NextFN
 */

/**
 * Our Context for each Request
 *
 * @typedef {Object} RequestContext
 *
 * @prop {http.IncomingMessage} req
 * @prop {http.ServerResponse} res
 * @prop {import('@/log').Logger} log
 * @prop {import('@/file-cache').FileCache} files An interface over the file system
 * @prop {import('@/errors/http')} errors Any errors that the middleware might need
 * @prop {Object<string, *>} query Any URL query args parsed by the server
 * @prop {Object<string, *>} params Any URL path params created by the route
 * @prop {import('url').UrlWithStringQuery} url The parsed URL
 */

/**
 * Our Middleware Function
 *
 * @typedef {function(RequestContext, NextFN): (Promise<void> | void)} Middleware
 */

/**
 * Compose Middleware into a single handler
 * 
 * @param {Array<Middleware>} middleware
 * @return {Middleware}
 */
function compose(middleware) {
  utils.invariant(
    Array.isArray(middleware),
    `You must give compose an array. Given ${typeof middleware} instead`
  )

  for (const fn of middleware) {
    utils.invariant(
      typeof fn === 'function',
      `All middleware must be a function, given ${typeof fn} instead`
    )
  }

  /**
   * @type {Middleware}
   */
  return (ctx, next) => {
    let index = -1

    const dispatch = (i) => {
      if (i <= index) {
        return Promise.reject(new Error('next() called multiple times'))
      }

      index = i

      let fn = middleware[i]

      if (i === middleware.length) {
        fn = next
      }

      if (!fn) {
        return Promise.resolve()
      }

      try {
        return Promise.resolve(fn(ctx, dispatch.bind(null, i + 1)));
      } catch (err) {
        return Promise.reject(err)
      }
    }

    return dispatch(0)
  }
}
/**
 * 
 * @param {RequestContext} ctx
 */
const send_response = async (ctx) => {
  const status = ctx.status > 99 && ctx.status < 600 ? ctx.status : 500
  ctx.res.statusCode = status

  if (typeof ctx.body === 'string') {
    return ctx.res.end(ctx.body)
  }

  if (ctx.body instanceof ReadStream) {
    return ctx.body.pipe(ctx.res)
  }

  if (ctx.body && typeof ctx.body === 'object') {
    return ctx.res.end(JSON.stringify(ctx.body))
  }

  ctx.res.end()
}

/**
 * Configuration Object for our Server
 * 
 * @typedef {Object} ServerConfig
 * 
 * @prop {import('@/log').Logger} log
 * @prop {import('@/file-cache').FileCache} files
 * @prop {import('@/errors/http')} errors
 */

/**
 * A Server is an abstraction over an HTTP Server.
 * It allows for Koa-inspired Middleware.
 */
class Server {
  /**
   * 
   * @param {ServerConfig} config
   */
  constructor({ log, files, errors }) {
    this._server = http.createServer(this._handler.bind(this))
    this._middlewares = new Set()
    this._log = log
    this._files = files
    this._errors = errors
  }

  /**
   * 
   * @param {http.IncomingMessage} req
   * @param {http.ServerResponse} res
   * @private
   */
  async _handler(req, res) {
    const middleware = [...this._middlewares.values()]

    const composed = compose(middleware)
    const ctx = this._createContext(req, res)

    await composed(ctx)

    await send_response(ctx)
  }

  /**
   * Starts the Server
   * 
   * @param {(string | number)} port The Port to listen on
   * @param {function(): void} cb Callback to call once started
   * @returns {Server} The Server Instance
   */
  start(port, cb) {
    utils.invariant(
      !this._instance,
      'You have tried to start a server that\'s already been started.'
    )

    this._instance = this._server.listen(port, cb)

    return this
  }

  /**
   * Stops the server
   * 
   * @param {function(): void} cb Callback to call once server stopped
   * @returns {Server}
   */
  stop(cb) {
    utils.invariant(
      this._instance,
      'You have tried to stop a server that\'s not been started.'
    )

    this._instance.close(cb)

    delete this._instance

    return this
  }

  /**
   * Adds middleware to the call stack
   * 
   * @param {Middleware} middleware The middle
   * @returns {Server} The server you called it on
   */
  use(middleware) {
    utils.invariant(
      typeof middleware === 'function',
      `Server.use must be given a function in order to work. You gave it a ${typeof middleware} instead`
    )

    this._middlewares.add(middleware)

    return this
  }

  remove(middleware) {
    utils.invariant(
      typeof middelware === 'function',
      `Server.remove must be given a function in order to work. You gave it a ${typeof middleware} instead`
    )

    this._middlewares.delete(middleware)

    return this
  }

  /**
   * How we create a context for the middleware
   * 
   * @param {http.IncomingMessage} req 
   * @param {http.ServerResponse} res 
   * @returns {RequestContext}
   * @private
   */
  _createContext(req, res) {
    const request = req

    const parsed_url = url.parse(req.url, true)

    request.url = parsed_url.pathname

    return {
      status: null,
      body: null,
      req: request,
      res,
      log: this._log,
      files: this._files,
      errors: this._errors,
      url: parsed_url,
      query: Object.assign({}, parsed_url.query),
    }
  }

  /**
   * Returns a callback for an http server addListener/
   * createServer
   */
  callback() {
    return this._handler.bind(this)
  }
}

module.exports = Object.assign(Server, {
  compose
})