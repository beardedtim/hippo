const http = require('http')
const utils = require('@/utils')

/**
 * Our Next Function
 *
 * @typedef {function(): (Promise<void> | void)} NextFN
 */

/**
 * Our Context for each Request
 *
 * @typedef {Object} RequestContext
 *
 * @prop {http.IncomingMessage} req
 * @prop {http.ServerResponse} res
 * @prop {import('@/log').Logger} log
 */

/**
 * Our Middleware Function
 *
 * @typedef {function(RequestContext, NextFN): (Promise<void> | void)} Middleware
 */

/**
 * Compose Middleware into a single handler
 * 
 * @param {Array<Middleware>} middleware
 * @return {Middleware}
 */
function compose(middleware) {
  utils.invariant(
    Array.isArray(middleware),
    `You must give compose an array. Given ${typeof middleware} instead`
  )

  for (const fn of middleware) {
    utils.invariant(
      typeof fn === 'function',
      `All middleware must be a function, given ${typeof fn} instead`
    )
  }

  /**
   * @type {Middleware}
   */
  return (ctx, next) => {
    let index = -1

    const dispatch = (i) => {
      if (i <= index) {
        return Promise.reject(new Error('next() called multiple times'))
      }

      index = i

      let fn = middleware[i]

      if (i === middleware.length) {
        fn = next
      }

      if (!fn) {
        return Promise.resolve()
      }

      try {
        return Promise.resolve(fn(ctx, dispatch.bind(null, i + 1)));
      } catch (err) {
        return Promise.reject(err)
      }
    }

    return dispatch(0)
  }
}

const prepare_body_for_response = body => {
  if (typeof body === 'string') {
    return body
  }

  return JSON.stringify(body)
}

/**
 * 
 * @param {RequestContext} ctx
 */
const send_response = async (ctx) => {
  const status = ctx.status > 99 && ctx.status < 600 ? ctx.status : 500

  if (
    // There is a body that was set
    ctx.body &&
    // and it is an object
    typeof ctx.body === 'object' &&
    // and we haven't already set the content-type
    !ctx.res.hasHeader('Content-Type')
  ) {
    // set the content type as JSON
    ctx.res.setHeader('Content-Type', 'application/json')
  }

  const body = await prepare_body_for_response(ctx.body)

  ctx.res.statusCode = status
  ctx.res.end(body)
}

/**
 * Configuration Object for our Server
 * 
 * @typedef {Object} ServerConfig
 * 
 * @prop {import('@/log').Logger} log
 */
class Server {
  /**
   * 
   * @param {ServerConfig} config
   */
  constructor({ log, files }) {
    this._server = http.createServer(this._handler.bind(this))
    this._middlewares = new Set()
    this._log = log
    this._files = files
  }

  /**
   * 
   * @param {http.IncomingMessage} req
   * @param {http.ServerResponse} res
   */
  async _handler(req, res) {
    const middleware = [...this._middlewares.values()]

    const composed = compose(middleware)
    const ctx = this._createContext(req, res)

    await composed(ctx)

    await send_response(ctx)
  }

  /**
   * Starts the Server
   * 
   * @param {(string | number)} port The Port to listen on
   * @param {function(): void} cb Callback to call once started
   * @returns {Server} The Server Instance
   */
  start(port, cb) {
    utils.invariant(
      !this._instance,
      'You have tried to start a server that\'s already been started.'
    )

    this._instance = this._server.listen(port, cb)

    return this
  }

  /**
   * Stops the server
   * 
   * @param {function(): void} cb Callback to call once server stopped
   * @returns {Server}
   */
  stop(cb) {
    utils.invariant(
      this._instance,
      'You have tried to stop a server that\'s not been started.'
    )

    this._instance.close(cb)

    delete this._instance

    return this
  }

  /**
   * Adds middleware to the call stack
   * 
   * @param {Middleware} middleware The middle
   * @returns {Server} The server you called it on
   */
  use(middleware) {
    utils.invariant(
      typeof middleware === 'function',
      `Server.use must be given a function in order to work. You gave it a ${typeof middleware} instead`
    )

    this._middlewares.add(middleware)

    return this
  }

  remove(middleware) {
    utils.invariant(
      typeof middelware === 'function',
      `Server.remove must be given a function in order to work. You gave it a ${typeof middleware} instead`
    )

    this._middlewares.delete(middleware)

    return this
  }

  _createContext(req, res) {
    return {
      status: null,
      body: null,
      req,
      res,
      log: this._log,
      files: this._files
    }
  }

  callback() {
    return this._handler.bind(this)
  }
}

module.exports = Server