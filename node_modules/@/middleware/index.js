const crypto = require('crypto')
const n_path = require('path')
const fs = require('fs')

const ffs = require('@/fs')
const env = require('@/env')
const utils = require('@/utils')
/**
 * 
 * @typedef {import('@/server').Middleware} Middleware
 */

/**
 * 
 * @type {function(): Middleware}
 */
module.exports.request_id = () => (ctx, next) => {
  ctx.res.setHeader('X-Req-ID', utils.uuid())

  return next()
}

/**
 * @type {function(string=): Middleware}
 */
module.exports.log_request = (log_level = 'trace') => (ctx, next) => {
  utils.invariant(
    log_level in ctx.log,
    `Must give log_request a log_level that is a known log level, given ${log_level} instead`
  )

  ctx.log[log_level]({ req: ctx.req, res: ctx.res })

  return next()
}

/**
 * @type {function(): Middleware}
 */
module.exports.catch_errors = () => async (ctx, next) => {
  try {
    await next()
  } catch (e) {
    const status = e.code > 99 && e.code < 600 ? e.code : 500
    const message = e.message

    ctx.status = status
    ctx.body = {
      error: {
        message
      }
    }
  }
}

/**
 * @type {function(string=): Middleware}
 */
module.exports.log_errors = (log_level = 'error') => async (ctx, next) => {
  utils.invariant(
    log_level in ctx.log,
    `Must give log_request a log_level that is a known log level, given ${log_level} instead`
  )

  try {
    await next()
  } catch (e) {
    ctx.log[log_level]({ req: ctx.res, res: ctx.res, err: e })
    throw e
  }
}

module.exports.request_time = () => async (ctx, next) => {
  const start = Date.now()
  await next()
  ctx.res.setHeader('X-Req-Time', Date.now() - start + 'ms')
}

const file_mappings = new Map([
  ['html', 'text/html'],
  ['css', 'text/css'],
  ['js', 'text/javascript'],
  ['gif', 'image/gif'],
  ['png', 'image/png'],
  ['jpg', 'image/jpeg'],
  ['jpeg', 'image/jpeg'],
  ['json', 'application/json'],
  ['jsonld', 'application/json'],
  ['ico', 'image/x-ico']
])

const get_file_ending = (possibleFilePath) => {
  const file_endings = [...file_mappings.keys()]
  const split = possibleFilePath.split('.')

  if (file_endings.includes(split[split.length - 1])) {
    return split[split.length - 1]
  }

  return false
}

const get_path = (possibleFilePath, index) => {
  if (get_file_ending(possibleFilePath)) {
    return possibleFilePath
  }

  if (index) {
    return get_path(n_path.join(possibleFilePath, 'index.html'), index)
  }
}

const get_headers_for_file = (file_path) => {
  const ending = get_file_ending(file_path)

  utils.invariant(
    ending,
    'You must give me a valid file in order to set its headers'
  )

  return {
    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type
    'Content-Type': file_mappings.get(ending),
    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control
    'Cache-Control': "max-age=604800"
  }
}

/**
 * Static Server Config
 * @typedef {Object} StaticServerConfig
 * 
 * @prop {string} public The directory of the public files that we want to server
 * @prop {boolean=true} index If we want to serve /index.html files from the path
 */

/**
 * Serve Static Files given a configuration
 * 
 * @param {StaticServerConfig} config
 * @returns {import('@/server').Middleware}
 */
module.exports.static_files = ({ public, index = true }) => async (ctx, next) => {
  // If we are not GETting the file
  if (ctx.req.method.toUpperCase() !== 'GET') {
    // do nothing
    return next()
  }

  // if we are here, we will try to send the static files
  let filePath = get_path(`${public}${ctx.req.url}`, index)

  utils.invariant(
    filePath,
    'You did not request a valid file'
  )

  try {
    // We need some meta-data about the file to set some headers
    const stats = await ffs.stats(filePath)
    const etag = crypto
      .createHash('md5')
      .update(JSON.stringify(stats))
      .digest('hex')// Set the 'Last-Modified'
    if (ctx.req.headers['if-none-match']) {
      const old_tag = ctx.req.headers['if-none-match']
      if (old_tag === etag) {
        ctx.status = 304
        return
      }
    }

    if (ctx.req.headers['if-none-modified']) {
      const last_modified = stats.mtimeMs
      const to_check = ctx.req.headers['if-none-modified']
      if (last_modified <= to_check) {
        ctx.status = 304
        return
      }
    }
    ctx.res.setHeader('Last-Modified', stats.mtimeMs)
    ctx.res.setHeader('ETag', etag)
    // We can just create a stream here since we
    // do not need to really read the file into
    // memory before serving
    const file = fs.createReadStream(filePath)

    // Get Headers for File
    const headers_to_set = get_headers_for_file(filePath)
    // Set headers
    for (const [key, value] of Object.entries(headers_to_set)) {
      ctx.res.setHeader(key, value)
    }

    // Attach body
    ctx.body = file
    ctx.status = 200
  } catch (e) {
    if (e.message.indexOf("Cannot Read File That Doesn't Exist")) {
      throw new ctx.errors.NotFound()
    } else {
      throw e
    }
  }
}

module.exports.security_headers = () => (ctx, next) => {
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Server
  ctx.res.setHeader('Server', 'Hippo')
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection
  ctx.res.setHeader('X-XSS-Protection', '1; mode=block')
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
  ctx.res.setHeader('X-Frame-Options', 'SAMEORIGIN')

  // Custom Headers
  // Who is the overlord of this server?
  const overlord_contact = env.string('OVERLORD_CONTACT', false)

  if (overlord_contact) {
    ctx.res.setHeader('X-OVERLORD', overlord_contact)
  }
  // What version of this server are we using?
  ctx.res.setHeader('x-Server-Version', 1)

  return next()
}

/**
 * @returns {import('@/server').Middleware}
 */
module.exports.not_found = () => async (ctx, next) => {
  await next()

  if (!ctx.body
    && ctx.status < 299) {
    throw new ctx.errors.NotFound()
  }
}