const fs = require('fs')
const { promisify } = require('util')
const utils = require('@/utils')

module.exports.readFile = promisify(fs.readFile)
module.exports.writeFile = promisify(fs.writeFile)

const exists = path => {
  utils.invariant(
    typeof path === 'string',
    `exists must be given a string, you gave it ${typeof path} instead`
  )

  new Promise(res => {
    fs.access(path, fs.constants.F_OK, (err) => {
      if (err) {
        res(false)
      } else {
        res(true)
      }
    });
  })
}

module.exports.exists = exists

const stats = promisify(fs.stat)

module.exports.stats = stats

const isDir = path => {
  utils.invariant(
    typeof path === 'string',
    `isDir must be given a string, you gave it ${typeof path} instead`
  )

  return new Promise(async res => {
    const stat = await stats(path)

    res(stat.isDirectory())
  })
}

const isFile = path => {
  utils.invariant(
    typeof path === 'string',
    `isFile must be given a string, you gave it ${typeof path} instead`
  )

  return new Promise(async res => {
    const stat = await stats(path)

    res(stat.isFile())
  })
}

module.exports.isDir = isDir
module.exports.isFile = isFile

const readdir = promisify(fs.readdir)

const build_file_tree = async (path, predicate = utils.id) => {
  // If they did not give us a predicate
  utils.invariant(
    typeof predicate === 'function',
    `requireDir must begiven a function as a second arg, you gave it ${typeof predicate} instead`
  )

  // if the path is not to a directory
  utils.invariant(
    await isDir(path),
    `You are trying to require something that is not a directory. Check your path of ${path}`
  )

  const files = await readdir(path)

  return Promise.all(files
    .filter(predicate)
    .map(async fileName => {
      if (await isFile(`${path}/${fileName}`)) {
        return `${path}/${fileName}`
      } else {
        return build_file_tree(`${path}/${fileName}`)
      }
    })
  )
    .then(list => list.reduce((a, c) => a.concat(c), []))
}
const requireDir = async (path, predicate) => {
  // Build up some tree that has the paths we need
  const tree = await build_file_tree(path, predicate)

  return tree
    // Map each path to be a tuple of path and module
    .map(fp => ([fp, require(fp)]))
    // reduce the tree into a single value by
    .reduce((acc, [filePath, mod]) => {
      // removing the leading path
      let mod_name = filePath.replace(path, '').slice(1, -3)

      // and if this is the index of the module
      if (mod_name.endsWith('/index')) {
        // we can just remove the /index from the string
        mod_name = mod_name.slice(0, -6)
      }

      acc[mod_name] = mod

      return acc
    }, {})
}

module.exports.requireDir = requireDir