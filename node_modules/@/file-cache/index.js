const fs = require('@/fs')
const { in_milli } = require('@/time')
/**
 * This module exposes a worker that sits on top of
 * the File System and has a LRU cache of files
 */

module.exports.create = ({ max_length = 100, max_ttl = Infinity } = {}) => {
  /**
  * The Cache is a map of URL -> File Content
  * 
  * We can get much cuter with this if we want to but for now, this should work for
  * simple HTML files
  * 
  * @type {Map<string, string>}
  */
  const cache = new Map()
  // If given a TTL, go through and delete any item that
  // has gone past it
  setInterval(() => {
    for(const [key, { created_at }] of cache.entries()) {
      if (Date.now() - created_at >= max_ttl) {
        cache.delete(key)
      }
    }
  }, in_milli.minute * 10)


  return ({
    has: async (path) => cache.has(path),
    set: async (path, str) => {
      cache.set(path, str)

      if (cache.size > max_length) {
        const orderded_by_use = [...cache.entries()].sort(([_, a], [__, b]) => {
          if (a.last_used > b.last_used) {
            return -1
          }

          if (b.last_used > a.last_used) {
            return 1
          }

          return 0
        })
        
        const last_item = orderded_by_use[orderded_by_use.length - 1]
        cache.delete(last_item[0])
      }
    },
    get: async (path) => {
      let file

      if (cache.has(path)) {
        const value = cache.get(path)
        file = value.file
        value.last_used = Date.now()
      } else {
        const exists = await fs.exists(path)

        file = await fs.readFile(path, 'utf8')
        await cache.set(path, { file, last_used: Date.now() })
      }
  
      return file
    }
  })
}