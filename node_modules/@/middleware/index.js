const crypto = require('crypto')
const n_path = require('path')

const env = require('@/env')
const utils = require('@/utils')
/**
 * 
 * @typedef {import('@/server').Middleware} Middleware
 */

/**
 * 
 * @type {function(): Middleware}
 */
module.exports.request_id = () => (ctx, next) => {
  ctx.res.setHeader('X-Req-ID', utils.uuid())

  return next()
}

/**
 * @type {function(string=): Middleware}
 */
module.exports.log_request = (log_level = 'trace') => (ctx, next) => {
  utils.invariant(
    log_level in ctx.log,
    `Must give log_request a log_level that is a known log level, given ${log_level} instead`
  )

  ctx.log[log_level]({ req: ctx.req, res: ctx.res })

  return next()
}

/**
 * @type {function(): Middleware}
 */
module.exports.catch_errors = () => async (ctx, next) => {
  try {
    await next()
  } catch (e) {
    const status = e.code > 99 && e.code < 600 ? e.code : 500
    const message = e.message

    ctx.status = status
    ctx.body = {
      error: {
        message
      }
    }
  }
}

/**
 * @type {function(string=): Middleware}
 */
module.exports.log_errors = (log_level = 'error') => async (ctx, next) => {
  utils.invariant(
    log_level in ctx.log,
    `Must give log_request a log_level that is a known log level, given ${log_level} instead`
  )

  try {
    await next()
  } catch (e) {
    console.dir(e)
    ctx.log[log_level]({ req: ctx.res, res: ctx.res, err: e })
    throw e
  }
}

module.exports.request_time = () => async (ctx, next) => {
  const start = Date.now()
  await next()
  ctx.res.setHeader('X-Req-Time', Date.now() - start + 'ms')
}

const file_mappings = new Map([
  ['html', 'text/html'],
  ['css', 'text/css'],
  ['js', 'text/javascript'],
  ['gif', 'image/gif'],
  ['jpg', 'image/jpeg'],
  ['jpeg', 'image/jpeg'],
  ['json', 'application/json'],
  ['jsonld', 'application/json'],
  ['ico', 'image/x-ico']
])

const get_file_ending = (possibleFilePath) => {
  const file_endings = [...file_mappings.keys()]
  const split = possibleFilePath.split('.')

  if (file_endings.includes(split[split.length - 1])) {
    return split[split.length - 1]
  }

  return false
}

const get_path = (possibleFilePath, index) => {
  if (get_file_ending(possibleFilePath)) {
    return possibleFilePath
  }

  if (index) {
    return get_path(n_path.join(possibleFilePath, 'index.html'), index)
  }
}

const get_headers_for_file = (file_path, file_content) => {
  const ending = get_file_ending(file_path)

  utils.invariant(
    ending,
    'You must give me a valid file in order to set its headers'
  )

  return {
    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type
    'Content-Type': file_mappings.get(ending),
    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag
    'ETag': crypto.createHash('md5').update(file_content).digest('hex'),
    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control
    'Cache-Control': "max-age=604800"
  }
}

/**
 * @returns {function(import('@/server').RequestContext, import('@/server').NextFN): Promise<void>}
 */
module.exports.static_files = ({ public, index = true }) => async (ctx, next) => {
    // If we are not GETting the file
    if (ctx.req.method.toUpperCase() !== 'GET') {
      // do nothing
      return next()
    }
  
    // if we are here, we will try to send the static files
    let filePath = get_path(`${public}${ctx.req.url}`, index)
  
    utils.invariant(
      filePath,
      'You did not request a valid file'
    )
   try {
    const file = await ctx.files.get(filePath)

    // Get Headers for File
    const headers_to_set = get_headers_for_file(filePath, file)
    // Set headers
    for (const [key, value] of Object.entries(headers_to_set)) {
      ctx.res.setHeader(key, value)
    }
    
    // Attach body
    ctx.body = file
    ctx.status = 200
   } catch (e) {
     if (e.message.indexOf("Cannot Read File That Doesn't Exist")) {
      ctx.status = 404
      ctx.body = ''
     } else {
       throw e
     }
   }
}

module.exports.security_headers = () => (ctx, next) => {
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Server
  ctx.res.setHeader('Server', 'Hippo')
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP
  ctx.res.setHeader('Content-Security-Policy', `default-src 'self'`)
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection
  ctx.res.setHeader('X-XSS-Protection', '1; mode=block')
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
  ctx.res.setHeader('X-Frame-Options', 'SAMEORIGIN')

  // Custom Headers
  // Who is the overlord of this server?
  const overlord_contact = env.string('OVERLORD_CONTACT', false)

  if(overlord_contact) {
    ctx.res.setHeader('X-OVERLORD', overlord_contact)
  }
  // What version of this server are we using?
  ctx.res.setHeader('x-Server-Version', 1)

  return next()
}