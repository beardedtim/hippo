const fs = require('@/fs')

/**
 * This module exposes a worker that sits on top of
 * the File System and has a LRU cache of files
 */

/**
 * 
 * @typedef {Object} FileCache
 * 
 * @prop {function(string): Promise<string>} get
 * @prop {function(string, string): Promise<string>} set
 * @prop {function(string): Promise<boolean>} has  
 */

/**
 * Cache Config
 * @typedef {Object} CacheConfig
 * 
 * @prop {number=100} max_length
 * @prop {import('@/log').Logger} log
 */

/**
 * Creates an cache of the file system
 * 
 * @param {CacheConfig} config
 * @returns {FileCache}
 */
module.exports.create = ({ max_length = 100, log }) => {
  /**
  * The Cache is a map of URL -> File Content
  * 
  * We can get much cuter with this if we want to but for now, this should work for
  * simple HTML files
  * 
  * @type {Map<string, string>}
  */
  const cache = new Map()
  const set = async (path, str) => {
    cache.set(path, str)

    if (cache.size > max_length) {
      const orderded_by_use = [...cache.entries()].sort(([_, a], [__, b]) => {
        if (a.last_used > b.last_used) {
          return -1
        }

        if (b.last_used > a.last_used) {
          return 1
        }

        return 0
      })

      const last_item = orderded_by_use[orderded_by_use.length - 1]
      cache.delete(last_item[0])
    }
  }

  const get = async (path) => {
    let file
    const value = await cache.get(path)
    const stats = await fs.stats(path)

    if (
      // We have seen this value before
      value &&
      // and the last time it was modified was
      // before we cached it
      stats.mtimeMs === value.mtimeMs
    ) {
      log.trace({ path, stats }, 'Cache Hit')

      file = value.file
      value.last_used = Date.now()
    } else {
      const stats = await fs.stats(path)
      log.trace({ path, stats }, 'Cache Miss')

      file = await fs.readFile(path, 'utf8')

      await set(path, {
        file,
        last_used: Date.now(),
        mtimeMs: stats.mtimeMs
      })
    }

    return file
  }

  const has = async (path) => cache.has(path)

  return ({
    has,
    set,
    get
  })
}