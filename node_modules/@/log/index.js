const fs = require('fs')
const asciiFormatting = require('@/ascii-formatting')
const utils = require('@/utils')
const StatusCodes = require('@/status_codes')

/**
 * Interface for a Log Function
 * 
 * @typedef {function((string | Object), string=): void} LogFN
 */

/**
 * Interface for a Logger
 * 
 * @typedef {Object} Logger
 * 
 * @property {LogFN} trace - The least important log level. Useful for random logs.
 * @property {LogFN} info - The default log level. Useful for getting information from the system
 * @property {LogFN} debug - The log level for when we are trying to figure something out.
 * @property {LogFN} warn - The log level we use when we want to say something weird happened but we are okay with it
 * @property {LogFN} error - The log level we use when an error happened that we did not expect
 * @property {LogFN} fatal - The log level we use when we exit the process
 */

const log_levels = new Map([
	[10, 'trace'],
	[20, 'info'],
	[30, 'debug'],
	[40, 'warn'],
	[50, 'error'],
	[60, 'fatal']
])

const word_to_number = word => {
	for (const [key, value] of log_levels.entries()) {
		if (value === word) {
			return key
		}
	}
}

const level_formatting = {
	trace: asciiFormatting.colors.fg.CYAN,
	info: asciiFormatting.colors.fg.BLUE,
	debug: asciiFormatting.colors.fg.WHITE,
	warn: asciiFormatting.colors.fg.YELLOW,
	error: asciiFormatting.colors.fg.RED,
	fatal: asciiFormatting.formatting.BOLD + asciiFormatting.colors.fg.RED
}

const console_transport = (name, str, log_formatting = false) => {
	if (log_formatting) {
		return console.log(level_formatting[name] + str + asciiFormatting.formatting.RESET)
	}

	return console.log(str)
}

const fileTransport = folderPath => (level, args) =>
	fs.appendFile(`${folderPath}/${level}.log`, args + '\n', (err) => {
		if (err) {
			// folder does not exist
			// so create it
			if (err.code === 'ENOENT') {
				fs.mkdir(folderPath, () => {
					fileTransport(folderPath)(level, args)
				})
			}
		}
	})

const named_log_fn = (name) =>
	({
		default_args,
		log_formatting = true,
		transports = [console_transport],
		serializer = utils.id
	}) =>
		(possibleObj, possibleMsg) => {
			const called_at = new Date().toISOString()

			const message = typeof possibleObj === 'string' ? possibleObj : possibleMsg
			const extraArgs = message === possibleObj ? {} : possibleObj

			const args = JSON.stringify(serializer({
				name,
				level: { number: word_to_number(name), name },
				timestamp: {
					logged_at: new Date().toISOString(),
					called_at
				},
				...default_args,
				...extraArgs,
				message,
			}))

			for (const transport of transports) {
				// transports _can_ be async but we do not care
				// to wait. We are calling them one after another
				// as they don't depend on each other and can be
				// called at the same time
				transport(name, args, log_formatting)
			}

		}

/**
 * @type {Logger}
 */
const logger_methods = [...log_levels.values()].reduce((a, name) => ({
	...a,
	[name]: named_log_fn(name)
}), {})

/**
 * The configuration we need to create a Log
 * 
 * @typedef {Object} LoggerConfig
 * 
 * @prop {string} name - The name of this specific log
 * @prop {(string | number)} level - The minimum level to log
 * @prop {*} values - An object of values that we want to log each time
 * @prop {boolean=false} colorized - If we want to colorize the output
 * @prop {Array<Transporter>} transports - The possible transports we want to use 
 * @prop {function(*): *} serializer - A function that serializes the arguments before stringifying them
 */

/**
 * Creates a new Logger
 * @param {LoggerConfig} config - The config to create the Logger with
 * @returns {Logger}
 */
const createLog = ({ name, level, values, colorized = false, transports, serializer }) => {
	// What is the minimum level we want to allow to log?
	const level_number = typeof level === 'string'
		? word_to_number(level)
		: level

	const logger = {}

	for (const [key, value] of log_levels.entries()) {
		// If the key is above or equal to what log is our minimum log level
		if (key >= level_number) {
			// then we get the logger method
			logger[value] = logger_methods[value]({ default_args: { name, ...values }, colorized, transports, serializer })
		} else {
			// if it is not, we are a noop
			logger[value] = utils.noop
		}
	}

	return logger
}

/**
 * Serializes a message for logging
 * 
 * @param {Object<string, *>} message The message we want to send
 * @returns {Object<string, *>}
 */
const serializer = (message) => {
	if (message.res) {
		message.res = {
			headers: message.res.getHeaders()
		}
	}

	if (message.req) {
		message.req = {
			url: message.req.url,
			method: message.req.method,
			headers: message.req.headers
		}
	}

	if (message.err) {
		message.err = {
			message: message.err.message,
			code: message.err.code,
			status: message.err.status,
			trace: message.err.stack
		}
	}

	return message
}

module.exports = Object.assign(createLog, {
	transports: {
		console: console_transport,
		file: fileTransport
	},
	serializer
})